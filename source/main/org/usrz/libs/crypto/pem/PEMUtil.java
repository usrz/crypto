/* ========================================================================== *
 * Copyright 2014 USRZ.com and Pier Paolo Fumagalli                           *
 * -------------------------------------------------------------------------- *
 * Licensed under the Apache License, Version 2.0 (the "License");            *
 * you may not use this file except in compliance with the License.           *
 * You may obtain a copy of the License at                                    *
 *                                                                            *
 *  http://www.apache.org/licenses/LICENSE-2.0                                *
 *                                                                            *
 * Unless required by applicable law or agreed to in writing, software        *
 * distributed under the License is distributed on an "AS IS" BASIS,          *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   *
 * See the License for the specific language governing permissions and        *
 * limitations under the License.                                             *
 * ========================================================================== */
package org.usrz.libs.crypto.pem;

import static org.usrz.libs.crypto.codecs.Base64Codec.BASE_64;
import static org.usrz.libs.crypto.codecs.CharsetCodec.UTF8;
import static org.usrz.libs.crypto.codecs.HexCodec.HEX;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.math.BigInteger;
import java.net.URL;
import java.security.GeneralSecurityException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.interfaces.RSAPrivateCrtKey;
import java.security.spec.RSAPrivateCrtKeySpec;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import org.usrz.libs.crypto.kdf.OpenSSLKDF;

import sun.security.util.DerInputStream;
import sun.security.util.DerValue;

/**
 * A simple utility file to read RSA keys and X509 certificates in PEM format
 * as generated by <a href="http://www.openssl.org/">OpenSSL</a>.
 *
 * @author <a href="mailto:pier@usrz.com">Pier Fumagalli</a>
 */
public final class PEMUtil {

    private static final Pattern BEGIN_CERTIFICATE = Pattern.compile("^--+BEGIN CERTIFICATE--+$");
    private static final Pattern END_CERTIFICATE =   Pattern.compile("^--+END CERTIFICATE--+$");

    private static final Pattern BEGIN_PRIVATE_KEY = Pattern.compile("^--+BEGIN (RSA )?PRIVATE KEY--+$");
    private static final Pattern END_PRIVATE_KEY =   Pattern.compile("^--+END (RSA )?PRIVATE KEY--+$");

    private static final Pattern BEGIN_PUBLIC_KEY = Pattern.compile("^--+BEGIN (RSA )?PRIVATE KEY--+$");
    private static final Pattern END_PUBLIC_KEY =   Pattern.compile("^--+END (RSA )?PRIVATE KEY--+$");

    private static final Pattern PRIVATE_KEY_ENCRYPTED = Pattern.compile("^Proc-Type: 4,ENCRYPTED$");
    private static final Pattern PRIVATE_KEY_ALGORITHM = Pattern.compile("^DEK-Info: ([^,]+),(.+)$");

    /* ====================================================================== */

    private PEMUtil() {
        throw new IllegalStateException("Do not construct");
    }

    /* ====================================================================== */
    /* X509 CERTIFICATES                                                      */
    /* ====================================================================== */

    /**
     * Load a (list of) X509 certificate(s) from the specified {@link File}.
     *
     * @throws CertificateException If the certificate was not invalid.
     * @throws PEMException If the PEM format was somehow broken.
     * @throws IOException If an I/O error occurred.
     */
    public static final List<X509Certificate> loadCertificates(File file)
    throws CertificateException, PEMException, IOException {
        if (file == null) throw new NullPointerException("Null file");
        return loadCertificates(file.toURI().toURL());
    }

    /**
     * Load a (list of) X509 certificate(s) from the specified {@link URL}.
     *
     * @throws CertificateException If the certificate was not invalid.
     * @throws PEMException If the PEM format was somehow broken.
     * @throws IOException If an I/O error occurred.
     */
    public static final List<X509Certificate> loadCertificates(URL url)
    throws CertificateException, PEMException, IOException {

        final InputStream stream = url.openStream();
        final InputStreamReader reader = new InputStreamReader(stream, UTF8);
        final LineNumberReader buffer = new LineNumberReader(reader);

        try {
            final List<X509Certificate> certificates = new ArrayList<>();
            final CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");

            final StringBuilder builder = new StringBuilder();

            String line;
            while ((line = buffer.readLine()) != null) {
                line = line.trim();

                /* Ignore empty lines */
                if (line.isEmpty()) continue;

                /* Make sure that we begin a certificate properly */
                if (BEGIN_CERTIFICATE.matcher(line).matches()) {
                    if (builder.length() == 0) continue;
                    throw new PEMException("Unexpected content \"" + line + "\"", url);
                }

                if (END_CERTIFICATE.matcher(line).matches()) {
                    if (builder.length() == 0) throw new PEMException("Empty certificate found", url);

                    /* Parse our Base64 certificate */
                    final byte[] certificateBytes;
                    try {
                        certificateBytes = BASE_64.decode(builder.toString());
                    } catch (IllegalArgumentException exception) {
                        throw new PEMException("Error decoding Base64 data", url);
                    }

                    /* Create our X509 certificate */
                    final ByteArrayInputStream certificateStream = new ByteArrayInputStream(certificateBytes);
                    final Certificate certificate = certificateFactory.generateCertificate(certificateStream);

                    /* Add our certificate to the list and reset the buffer */
                    try {
                        certificates.add((X509Certificate) certificate);
                    } catch (ClassCastException exception) {
                        throw new PEMException("Exception casting certificate", url, exception);
                    }
                    builder.setLength(0);
                    continue;
                }

                /* In all other case, let's hope this is a Base64 line */
                builder.append(line);

            }

            /* Check we don't have a hanging certificate */
            if (builder.length() != 0) throw new PEMException("Unterminated certificate", url);

            /* Check if we read any certificate */
            if (certificates.size() > 0) return certificates;
            throw new PEMException("No certificates found", url);

        } finally {
            /* Close all */
            buffer.close();
            reader.close();
            stream.close();
        }
    }

    /* ====================================================================== */
    /* PRIVATE KEYS                                                           */
    /* ====================================================================== */

    /**
     * Load a RSA private key from the specified {@link File}.
     *
     * @throws GeneralSecurityException If the key could not be loaded.
     * @throws PEMException If the PEM format was somehow broken.
     * @throws IOException If an I/O error occurred.
     */
    public static final RSAPrivateCrtKey loadPrivateKey(File file)
    throws GeneralSecurityException, PEMException, IOException {
        return loadPrivateKey(file, (byte[]) null);
    }

    /**
     * Load a RSA private key from the specified {@link URL}.
     *
     * @throws GeneralSecurityException If the key could not be loaded.
     * @throws PEMException If the PEM format was somehow broken.
     * @throws IOException If an I/O error occurred.
     */
    public static final RSAPrivateCrtKey loadPrivateKey(URL url)
    throws GeneralSecurityException, PEMException, IOException {
        return loadPrivateKey(url, (byte[]) null);
    }

    /**
     * Load a RSA private key from the specified {@link File} using the
     * specified password (in UTF-8) to decrypt it.
     *
     * @throws GeneralSecurityException If the key could not be loaded.
     * @throws PEMException If the PEM format was somehow broken.
     * @throws IOException If an I/O error occurred.
     */
    public static final RSAPrivateCrtKey loadPrivateKey(File file, String password)
    throws GeneralSecurityException, PEMException, IOException {
        return loadPrivateKey(file.toURI().toURL(), password);
    }

    /**
     * Load a RSA private key from the specified {@link URL} using the
     * specified password (in UTF-8) to decrypt it.
     *
     * @throws GeneralSecurityException If the key could not be loaded.
     * @throws PEMException If the PEM format was somehow broken.
     * @throws IOException If an I/O error occurred.
     */
    public static final RSAPrivateCrtKey loadPrivateKey(URL url, String password)
    throws GeneralSecurityException, PEMException, IOException {
        return loadPrivateKey(url, password == null? null: password.getBytes(UTF8));
    }

    /**
     * Load a RSA private key from the specified {@link File} using the
     * specified password to decrypt it.
     *
     * @throws GeneralSecurityException If the key could not be loaded.
     * @throws PEMException If the PEM format was somehow broken.
     * @throws IOException If an I/O error occurred.
     */
    public static final RSAPrivateCrtKey loadPrivateKey(File file, byte[] password)
    throws GeneralSecurityException, PEMException, IOException {
        return loadPrivateKey(file.toURI().toURL(), password);
    }

    /**
     * Load a RSA private key from the specified {@link URL} using the
     * specified password to decrypt it.
     *
     * @throws GeneralSecurityException If the key could not be loaded.
     * @throws PEMException If the PEM format was somehow broken.
     * @throws IOException If an I/O error occurred.
     */
    public static final RSAPrivateCrtKey loadPrivateKey(URL url, byte[] password)
    throws GeneralSecurityException, PEMException, IOException {

        final InputStream stream = url.openStream();
        final InputStreamReader reader = new InputStreamReader(stream, UTF8);
        final LineNumberReader buffer = new LineNumberReader(reader);

        try {
            final KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            final StringBuilder builder = new StringBuilder();

            RSAPrivateCrtKey privateKey = null;
            String line = null;
            String encryptionAlgorithm = null;
            String encryptionSalt = null;
            while ((line = buffer.readLine()) != null) {
                line = line.trim();

                /* Ignore empty lines */
                if (line.isEmpty()) continue;

                /* Make sure that we begin a private key properly */
                if (BEGIN_PRIVATE_KEY.matcher(line).matches()) {
                    if ((builder.length() == 0) && (privateKey == null)) continue;
                    throw new PEMException("Unexpected content \"" + line + "\"", url);
                }

                /* If we already have a private key, simply fail */
                if (privateKey != null) {
                    throw new PEMException("Unexpected content \"" + line + "\"", url);
                }

                /* Check if this is an encrypted key */
                if (PRIVATE_KEY_ENCRYPTED.matcher(line).matches()) continue;
                final Matcher encryptionMatcher = PRIVATE_KEY_ALGORITHM.matcher(line);
                if (encryptionMatcher.matches()) {
                    encryptionAlgorithm = encryptionMatcher.group(1);
                    encryptionSalt = encryptionMatcher.group(2);
                    continue;
                }


                /* On end of private keys, parse */
                if (END_PRIVATE_KEY.matcher(line).matches()) {
                    if (builder.length() == 0) throw new PEMException("Empty private key found", url);

                    /* Parse our Base64 private key */
                    final byte[] privateKeyBytes;
                    try {
                        privateKeyBytes = BASE_64.decode(builder.toString());
                    } catch (IllegalArgumentException exception) {
                        throw new PEMException("Error decoding Base64 data", url);
                    }

                    /* Potentially decrypt the key */
                    final byte[] decryptedKey = decrypt(privateKeyBytes, encryptionAlgorithm, encryptionSalt, password);

                    /* Deconstruct the DER-encoded sequence to get our key values */
                    final RSAPrivateCrtKeySpec privateKeySpec = parsePrivateKey(decryptedKey, url);

                    /* Create our RSA private key, reset our buffer, and go! */
                    try {
                        privateKey = (RSAPrivateCrtKey) keyFactory.generatePrivate(privateKeySpec);
                    } catch (ClassCastException exception) {
                        throw new PEMException("Exception casting private key", url, exception);
                    }
                    builder.setLength(0);
                    continue;
                }

                /* In all other case, let's hope this is a Base64 line */
                builder.append(line);

            }

            /* Check we don't have a hanging private key */
            if (builder.length() != 0) throw new PEMException("Unterminated private key", url);

            return privateKey;

        } finally {
            /* Close all */
            buffer.close();
            reader.close();
            stream.close();
        }

    }

    /* ====================================================================== */

    private static final byte[] decrypt(byte[] data, String algorithm, String salt, byte[] password)
    throws InvalidKeyException, NoSuchAlgorithmException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {

        /* Check if we have to / can decode */
        if (algorithm == null) return data;
        if (password == null) throw new InvalidKeyException("No password supplied");

        /* Prepare our data */
        String cipherType = null;
        String keyType = null;
        int keyLength = -1;
        switch(algorithm.toUpperCase()) {
            case "DES-CBC"      : cipherType = "DES/CBC/PKCS5Padding";    keyType = "DES";    keyLength =  8; break;
            case "DES-EDE3-CBC" : cipherType = "DESede/CBC/PKCS5Padding"; keyType = "DESede"; keyLength = 24; break;
            case "AES-128-CBC"  : cipherType = "AES/CBC/PKCS5Padding";    keyType = "AES";    keyLength = 16; break;
            case "AES-192-CBC"  : cipherType = "AES/CBC/PKCS5Padding";    keyType = "AES";    keyLength = 24; break;
            case "AES-256-CBC"  : cipherType = "AES/CBC/PKCS5Padding";    keyType = "AES";    keyLength = 32; break;
            default: throw new NoSuchAlgorithmException("Decryption with " + algorithm + " unsupported");
        }

        /* Get our cipher */
        final Cipher cipher;;
        try {
            cipher = Cipher.getInstance(cipherType);
        } catch (NoSuchPaddingException exception) {
            throw new NoSuchAlgorithmException("Padding for " + cipherType + " unsupported");
        }

        /* Prepare the encryption key MD5(key+salt) */
        final byte[] key =  new OpenSSLKDF(keyLength).deriveKey(password, HEX.decode(salt));

        final SecretKeySpec pKey = new SecretKeySpec(key, 0, keyLength, keyType);
        final IvParameterSpec ivectorSpecv = new IvParameterSpec(HEX.decode(salt));

        cipher.init(Cipher.DECRYPT_MODE, pKey, ivectorSpecv);
        return cipher.doFinal(data);
    }

    /* ====================================================================== */

    private static final RSAPrivateCrtKeySpec parsePrivateKey(byte[] privateKeyBytes, URL url)
    throws PEMException {
        try {
            final DerInputStream derInputStream = new DerInputStream(privateKeyBytes);
            final DerValue[] values = derInputStream.getSequence(0);

            int version = values[0].getInteger();
            if (version != 0) throw new PEMException("Invalid version " + version + " for key", url);
            if (values.length < 9) throw new PEMException("Invalid number of ASN.1 values for key", url);

            final BigInteger modulus = values[1].getBigInteger();
            final BigInteger publicExponent = values[2].getBigInteger();
            final BigInteger privateExponent = values[3].getBigInteger();
            final BigInteger prime1 = values[4].getBigInteger();
            final BigInteger prime2 = values[5].getBigInteger();
            final BigInteger exponent1 = values[6].getBigInteger();
            final BigInteger exponent2 = values[7].getBigInteger();
            final BigInteger coefficient = values[8].getBigInteger();

            return new RSAPrivateCrtKeySpec(modulus,
                                            publicExponent,
                                            privateExponent,
                                            prime1,
                                            prime2,
                                            exponent1,
                                            exponent2,
                                            coefficient);
        } catch (IOException exception) {
            throw new PEMException("Exception parsing ASN.1 format", url, exception);
        }

    }
}
